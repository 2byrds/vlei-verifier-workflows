/**
 * Represents a secret used for authentication
 */
export interface Secret {
  [key: string]: string;
}

/**
 * Represents credential attributes
 */
export interface CredentialAttributes {
  [key: string]: any;
}

/**
 * Represents a credential source
 */
export interface CredentialSource {
  type: string;
  o?: string;
}

/**
 * Represents a credential configuration
 */
export interface Credential {
  type: string;
  schema: string;
  privacy: boolean;
  attributes: CredentialAttributes;
  credSource?: CredentialSource;
  rules?: string;
}

/**
 * Represents an agent configuration
 */
export interface Agent {
  secret: string;
}

export interface IdentifierData {
  type: 'singlesig' | 'multisig';
  name: string;
  delegator?: string;
}

export interface SinglesigIdentifierData extends IdentifierData {
  agent: { name: string; secret: string };
}

export interface MultisigIdentifierData extends IdentifierData {
  identifiers: string[];
  isith: string;
  nsith: string;
}

/**
 * Represents a user in the system
 */
export interface User {
  type: string;
  alias: string;
  identifiers: string[];
}

/**
 * Represents credential information
 */
export interface CredentialInfo {
  type: string;
  schema: string;
  rules?: string;
  privacy: boolean;
  attributes: any;
  credSource?: any;
}

/**
 * Main configuration class that represents the entire configuration structure
 */
export class Configuration {
  secrets: { [key: string]: string };
  credentials: { [key: string]: Credential };
  agents: { [key: string]: Agent };
  identifiers: { [key: string]: IdentifierData };
  users: User[];

  /**
   * Creates a new Configuration instance
   * 
   * @param config The configuration object to parse
   */
  constructor(config: any) {
    this.secrets = config.secrets || {};
    this.credentials = config.credentials || {};
    this.agents = config.agents || {};
    this.identifiers = config.identifiers || {};
    this.users = config.users || [];
  }

  /**
   * Gets a secret by its key
   * 
   * @param key The secret key
   * @returns The secret value or undefined if not found
   */
  getSecret(key: string): string | undefined {
    return this.secrets[key];
  }

  /**
   * Gets an agent by its name
   * 
   * @param name The agent name
   * @returns The agent configuration or undefined if not found
   */
  getAgent(name: string): Agent | undefined {
    return this.agents[name];
  }

  /**
   * Gets an agent's secret
   * 
   * @param agentName The agent name
   * @returns The agent's secret or undefined if not found
   */
  getAgentSecret(agentName: string): string | undefined {
    const agent = this.getAgent(agentName);
    if (!agent) return undefined;
    
    return this.getSecret(agent.secret);
  }

  /**
   * Gets an identifier by its name
   * 
   * @param name The identifier name
   * @returns The identifier configuration or undefined if not found
   */
  getIdentifierByName(name: string): IdentifierData | undefined {
    return this.identifiers[name];
  }

  /**
   * Checks if an identifier is a multi-signature identifier
   * 
   * @param identifier The identifier to check
   * @returns True if the identifier is a multi-signature identifier, false otherwise
   */
  isMultisigIdentifier(identifier: IdentifierData): identifier is MultisigIdentifierData {
    return 'identifiers' in identifier;
  }

  /**
   * Gets a credential by its name
   * 
   * @param name The credential name
   * @returns The credential configuration or undefined if not found
   */
  getCredential(name: string): Credential | undefined {
    return this.credentials[name];
  }

  /**
   * Gets a user by its alias
   * 
   * @param alias The user alias
   * @returns The user configuration or undefined if not found
   */
  getUserByAlias(alias: string): User | undefined {
    return this.users.find(user => user.alias === alias);
  }

  /**
   * Gets users by type
   * 
   * @param type The user type
   * @returns An array of users with the specified type
   */
  getUsersByType(type: string): User[] {
    return this.users.filter(user => user.type === type);
  }

  /**
   * Gets all identifiers for a user
   * 
   * @param userAlias The user alias
   * @returns An array of identifier configurations for the user
   */
  getUserIdentifiers(userAlias: string): IdentifierData[] {
    const user = this.getUserByAlias(userAlias);
    if (!user) return [];
    
    return user.identifiers
      .map(id => getIdentifierData(this,id))
      .filter((id): id is IdentifierData => id !== undefined);
  }

  /**
   * Builds a map of credential information
   * 
   * @returns A map of credential information
   */
  buildCredentials(): Map<string, CredentialInfo> {
    let credentials: Map<string, CredentialInfo> = new Map<
      string,
      CredentialInfo
    >();
    
    for (const key in this.credentials) {
      const cred = this.credentials[key];
      let curCred: CredentialInfo = {
        type: cred.type,
        schema: cred.schema,
        rules: cred.rules,
        privacy: cred.privacy,
        attributes: cred.attributes,
        credSource: cred.credSource,
      };
      credentials.set(key, curCred);
    }
    
    return credentials;
  }

  /**
   * Creates a Configuration instance from a JSON file
   * 
   * @param filePath The path to the JSON file
   * @returns A Promise that resolves to a Configuration instance
   */
  static async fromFile(filePath: string): Promise<Configuration> {
    try {
      const fs = require('fs');
      const util = require('util');
      const readFile = util.promisify(fs.readFile);
      
      const data = await readFile(filePath, 'utf8');
      const config = JSON.parse(data);
      
      return new Configuration(config);
    } catch (error) {
      throw new Error(`Failed to load configuration from ${filePath}: ${error}`);
    }
  }

  /**
   * Creates a Configuration instance from a JSON object
   * 
   * @param json The JSON object
   * @returns A Configuration instance
   */
  static fromJson(json: any): Configuration {
    return new Configuration(json);
  }
}

/**
 * Helper function to load a configuration from a file
 * 
 * @param filePath The path to the configuration file
 * @returns A Promise that resolves to a Configuration instance
 */
export async function loadConfiguration(filePath: string): Promise<Configuration> {
  return Configuration.fromFile(filePath);
}

/**
 * Helper function to get agent secret
 * @deprecated Use Configuration.getAgentSecret instead
 */
export function getAgentSecret(config: Configuration, agentName: string): string {
  const secret = config.getAgentSecret(agentName);
  if (!secret) {
    throw new Error(`Secret not found for agent: ${agentName}`);
  }
  return secret;
}

export async function buildAidData(config: Configuration): Promise<any> {
  const identifiers = structuredClone(config.identifiers);
  for (const key of Object.keys(identifiers)) {
    if ('agent' in identifiers[key]) {
      const id = identifiers[key] as SinglesigIdentifierData;
      const agentName = id.agent;
      id.agent = {
        name: agentName,
        secret: config.agents[agentName].secret,
      };
    }
  }
  return identifiers;
}

export function getIdentifierData(
  jsonConfig: any,
  aidName: string
): IdentifierData {
  const identifier = jsonConfig.identifiers?.[aidName];

  // Check if identifier exists
  if (!identifier) {
    throw new Error(`Identifier not found: ${aidName}`);
  }

  if (identifier.identifiers) {
    return {
      type: 'multisig',
      ...identifier,
    } as MultisigIdentifierData;
  }

  // Make sure agent exists
  if (!identifier.agent || !jsonConfig.agents?.[identifier.agent]) {
    throw new Error(`Agent not found for identifier: ${aidName}`);
  }

  const agent = jsonConfig.agents[identifier.agent];

  // Make sure secret exists
  if (!agent.secret || !jsonConfig.secrets?.[agent.secret]) {
    throw new Error(`Secret not found for agent: ${identifier.agent}`);
  }

  const secret = jsonConfig.secrets[agent.secret];

  return {
    type: 'singlesig',
    ...identifier,
    agent: {
      name: identifier.agent,
      secret: secret,
    },
  } as SinglesigIdentifierData;
}